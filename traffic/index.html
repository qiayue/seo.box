<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç½‘ç«™æµé‡æ•°æ®åˆ†æå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin: 30px 0;
            background: linear-gradient(45deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: linear-gradient(45deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: linear-gradient(45deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.3));
        }

        .upload-icon {
            font-size: 3em;
            color: #667eea;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.2em;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .upload-hint {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        input[type="file"] {
            display: none;
        }

        .url-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-left: 5px solid;
            transition: all 0.3s ease;
        }

        .url-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .url-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .url-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #2c3e50;
            word-break: break-all;
        }

        .url-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
            padding: 10px 15px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
        }

        .stat-label {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: 600;
            color: #2c3e50;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
            background: #fafafa;
            border-radius: 10px;
            padding: 10px;
        }

        .no-data {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
            font-size: 1.1em;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.1em;
            color: #667eea;
        }

        .summary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .summary h3 {
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .color-0 { border-left-color: #e74c3c; }
        .color-1 { border-left-color: #3498db; }
        .color-2 { border-left-color: #2ecc71; }
        .color-3 { border-left-color: #f39c12; }
        .color-4 { border-left-color: #9b59b6; }
        .color-5 { border-left-color: #1abc9c; }
        .color-6 { border-left-color: #e67e22; }
        .color-7 { border-left-color: #34495e; }
        .color-8 { border-left-color: #e91e63; }
        .color-9 { border-left-color: #00bcd4; }

        .key-points {
            margin: 20px 0;
            padding: 20px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
        }

        .key-points h4 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .points-list {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .point-item {
            background: white;
            padding: 12px 15px;
            border-radius: 8px;
            border-left: 4px solid;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 200px;
            transition: transform 0.2s ease;
        }

        .point-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .point-date {
            font-size: 0.85em;
            color: #6c757d;
            margin-bottom: 4px;
        }

        .point-label {
            font-weight: 600;
            font-size: 0.95em;
            margin-bottom: 4px;
        }

        .point-desc {
            font-size: 0.8em;
            color: #495057;
            line-height: 1.3;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .url-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .url-stats {
                width: 100%;
                justify-content: space-around;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ ç½‘ç«™æµé‡æ•°æ®åˆ†æå™¨</h1>
        
        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">ğŸ“Š</div>
            <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ CSVæ–‡ä»¶</div>
            <div class="upload-hint">æ”¯æŒåŒ…å«æ—¶é—´å’ŒURLè®¿é—®é‡æ•°æ®çš„CSVæ–‡ä»¶</div>
            <input type="file" id="fileInput" accept=".csv" />
        </div>

        <div id="results"></div>
    </div>

    <script>
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#e91e63', '#00bcd4'
        ];

        let chartInstances = [];

        document.getElementById('uploadArea').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        // æ‹–æ‹½åŠŸèƒ½
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.csv')) {
                alert('è¯·ä¸Šä¼ CSVæ–‡ä»¶');
                return;
            }

            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">æ­£åœ¨è§£ææ–‡ä»¶...</div>';

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    processData(results.data);
                },
                error: function(error) {
                    resultsDiv.innerHTML = '<div class="no-data">æ–‡ä»¶è§£æå¤±è´¥: ' + error.message + '</div>';
                }
            });
        }

        function processData(data) {
            // æ¸…ç†ä¹‹å‰çš„å›¾è¡¨
            chartInstances.forEach(chart => chart.destroy());
            chartInstances = [];

            if (!data || data.length === 0) {
                document.getElementById('results').innerHTML = '<div class="no-data">æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆæ•°æ®</div>';
                return;
            }

            // è·å–æ‰€æœ‰URLåˆ—ï¼ˆæ’é™¤æ—¥æœŸåˆ—ï¼‰
            const firstRow = data[0];
            const urlColumns = Object.keys(firstRow).filter(key => 
                key.toLowerCase() !== 'date' && 
                key.trim() !== ''
            );

            if (urlColumns.length === 0) {
                document.getElementById('results').innerHTML = '<div class="no-data">æ²¡æœ‰æ‰¾åˆ°URLæ•°æ®åˆ—</div>';
                return;
            }

            // è§£ææ‰€æœ‰æ—¥æœŸå¹¶æ‰¾åˆ°æœ‰æ•°æ®çš„æœ€æ—©æ—¥æœŸ
            const allDatesWithData = [];
            data.forEach(row => {
                const date = row.Date || row.date || Object.values(row)[0];
                if (date && !isNaN(new Date(date).getTime())) {
                    // æ£€æŸ¥è¿™ä¸€å¤©æ˜¯å¦æœ‰ä»»ä½•URLæœ‰æµé‡æ•°æ®
                    const hasTraffic = urlColumns.some(url => {
                        const traffic = parseInt(row[url]) || 0;
                        return traffic > 0;
                    });
                    
                    if (hasTraffic) {
                        allDatesWithData.push(date);
                    }
                }
            });

            // æ‰¾åˆ°æœ€æ—©æœ‰æ•°æ®çš„æ—¥æœŸ
            const earliestDataDate = allDatesWithData.length > 0 ? 
                allDatesWithData.sort((a, b) => new Date(a) - new Date(b))[0] : null;

            // æ”¶é›†æ‰€æœ‰æœ‰æ•ˆæ—¥æœŸ
            const validDates = data
                .map(row => row.Date || row.date || Object.values(row)[0])
                .filter(date => date && !isNaN(new Date(date).getTime()))
                .map(date => new Date(date));

            // å¤„ç†æ¯ä¸ªURLçš„æ•°æ®
            let globalEarliestLaunchDate = null;
            let homepageIndex = 0;
            const urlData = urlColumns.map((url, index) => {
                const urlTraffic = data.map(row => ({
                    date: row.Date || row.date || Object.values(row)[0],
                    traffic: parseInt(row[url]) || 0
                })).filter(item => item.date && !isNaN(new Date(item.date).getTime()));

                // å¦‚æœæœ‰æœ€æ—©æ•°æ®æ—¥æœŸï¼Œä»é‚£ä¸ªæ—¥æœŸå¼€å§‹æ˜¾ç¤ºæ•°æ®
                let filteredTraffic = urlTraffic;
                if (earliestDataDate) {
                    const startDate = new Date(earliestDataDate);
                    filteredTraffic = urlTraffic.filter(item => new Date(item.date) >= startDate);
                }

                // æ‰¾åˆ°ç¬¬ä¸€æ¬¡æœ‰æµé‡çš„æ—¶é—´ï¼ˆä¸Šçº¿æ—¶é—´ï¼‰ï¼Œä¸”æ—¥æœŸæœ‰æ•ˆä¸”å¤§äºç­‰äºæ•°æ®æœ€æ—©æ—¥æœŸ
                const launchDate = filteredTraffic.find(item =>
                    item.traffic > 0 &&
                    item.date && !isNaN(new Date(item.date).getTime()) &&
                    validDates.length > 0 && new Date(item.date) >= validDates[0]
                )?.date;
                // è®°å½•å…¨å±€æœ€æ—©ä¸Šçº¿æ—¶é—´
                if (launchDate) {
                    if (!globalEarliestLaunchDate || new Date(launchDate) < new Date(globalEarliestLaunchDate)) {
                        globalEarliestLaunchDate = launchDate;
                    }
                }
                // åˆ¤æ–­æ˜¯å¦ä¸ºé¦–é¡µï¼ˆæ— è·¯å¾„æˆ–åªæœ‰åŸŸåï¼‰
                if (homepageIndex === 0) {
                    try {
                        const u = new URL(url);
                        if (!u.pathname || u.pathname === '/' || u.pathname === '') {
                            homepageIndex = index;
                        }
                    } catch (e) {}
                }
                // åˆ†æå…³é”®èŠ‚ç‚¹
                const keyPoints = analyzeKeyPoints(filteredTraffic, launchDate);
                // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
                const totalTraffic = filteredTraffic.reduce((sum, item) => sum + item.traffic, 0);
                const maxTraffic = Math.max(...filteredTraffic.map(item => item.traffic));
                const avgTraffic = filteredTraffic.length > 0 ? Math.round(totalTraffic / filteredTraffic.length) : 0;

                return {
                    url: url.replace(/^https?:\/\//, '').replace(/\/$/, ''),
                    fullUrl: url,
                    data: filteredTraffic,
                    launchDate,
                    keyPoints,
                    totalTraffic,
                    maxTraffic,
                    avgTraffic,
                    color: colors[index % colors.length],
                    colorClass: `color-${index % 10}`,
                    earliestDataDate
                };
            }).filter(item => item.data.length > 0);

            // æ£€æŸ¥å¹¶ä¿®æ­£é¦–é¡µä¸Šçº¿æ—¶é—´ï¼ˆæ— æ¡ä»¶ï¼‰
            if (urlData.length > 0 && globalEarliestLaunchDate) {
                const homepage = urlData[homepageIndex] || urlData[0];
                let earliestStr = typeof globalEarliestLaunchDate === 'string'
                    ? globalEarliestLaunchDate
                    : globalEarliestLaunchDate.toISOString().slice(0, 10);
                homepage.launchDate = earliestStr;
                // é‡æ–°åˆ†æå…³é”®èŠ‚ç‚¹ï¼Œä¿è¯é¦–é¡µæ‰€æœ‰äº‹ä»¶ä»¥æœ€æ—©ä¸Šçº¿æ—¶é—´ä¸ºèµ·ç‚¹
                homepage.keyPoints = analyzeKeyPoints(homepage.data, homepage.launchDate);
            }

            renderResults(urlData, earliestDataDate);
        }

        function analyzeKeyPoints(trafficData, launchDate) {
            let keyPoints = [];
            
            // ç”¨äºè·Ÿè¸ªå·²è¢«å ç”¨çš„æ—¶é—´æ®µï¼Œé¿å…é‡åˆ
            const occupiedPeriods = [];
            function isTimeOverlap(startDate, endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);
                return occupiedPeriods.some(period => {
                    const periodStart = new Date(period.start);
                    const periodEnd = new Date(period.end);
                    return (start <= periodEnd && end >= periodStart);
                });
            }
            function addOccupiedPeriod(startDate, endDate) {
                occupiedPeriods.push({
                    start: startDate,
                    end: endDate
                });
            }

            if (!trafficData || trafficData.length < 2) return keyPoints;

            // åªåˆ†æä¸Šçº¿æ—¶é—´ä¹‹åçš„æ•°æ®
            let validStartIdx = 0;
            if (launchDate) {
                validStartIdx = trafficData.findIndex(item => item.date === launchDate);
                if (validStartIdx === -1) validStartIdx = 0;
            }

            // 1. å…ˆè¯†åˆ«é•¿æœŸè¶‹åŠ¿äº‹ä»¶ (ä¼˜å…ˆçº§æœ€é«˜)
            // æŒç»­å¢é•¿æœŸ (è‡³å°‘7å¤©)
            let growthStreak = 0;
            let growthStart = null;
            let growthStartValue = 0;
            for (let i = Math.max(1, validStartIdx); i < trafficData.length; i++) {
                if (trafficData[i].traffic > trafficData[i-1].traffic) {
                    if (growthStreak === 0) {
                        growthStart = trafficData[i-1].date;
                        growthStartValue = trafficData[i-1].traffic;
                    }
                    growthStreak++;
                } else {
                    if (growthStreak >= 7) {
                        let growthEnd = trafficData[i-1].date;
                        let endValue = trafficData[i-1].traffic;
                        // ä¿®æ­£å¢é•¿æœŸèµ·ç‚¹ä¸èƒ½æ—©äºä¸Šçº¿æ—¶é—´
                        if (launchDate && new Date(growthStart) < new Date(launchDate)) {
                            growthStart = launchDate;
                            growthStartValue = trafficData.find(item => item.date === launchDate)?.traffic || 0;
                        }
                        // èµ·ç‚¹ä¸º0åˆ™è·³è¿‡
                        if (growthStartValue > 0 && !isTimeOverlap(growthStart, growthEnd)) {
                            const totalGrowth = ((endValue - growthStartValue) / growthStartValue * 100).toFixed(1);
                            keyPoints.push({
                                date: growthStart,
                                endDate: growthEnd,
                                type: 'growth_period',
                                label: `æŒç»­å¢é•¿æœŸ ${formatDate(growthStart)} - ${formatDate(growthEnd)}`,
                                description: `è¿ç»­å¢é•¿${growthStreak}å¤© (${growthStartValue.toLocaleString()} â†’ ${endValue.toLocaleString()}ï¼Œå¢é•¿${totalGrowth}%)`,
                                color: '#27ae60'
                            });
                            addOccupiedPeriod(growthStart, growthEnd);
                        }
                    }
                    growthStreak = 0;
                }
            }

            // æŒç»­ä¸‹é™æœŸ (è‡³å°‘5å¤©)
            let declineStreak = 0;
            let declineStart = null;
            let declineStartValue = 0;
            for (let i = Math.max(1, validStartIdx); i < trafficData.length; i++) {
                if (trafficData[i].traffic < trafficData[i-1].traffic && trafficData[i-1].traffic > 0) {
                    if (declineStreak === 0) {
                        declineStart = trafficData[i-1].date;
                        declineStartValue = trafficData[i-1].traffic;
                    }
                    declineStreak++;
                } else {
                    if (declineStreak >= 5) {
                        const declineEnd = trafficData[i-1].date;
                        const endValue = trafficData[i-1].traffic;
                        
                        if (!isTimeOverlap(declineStart, declineEnd)) {
                            const totalDecline = ((declineStartValue - endValue) / declineStartValue * 100).toFixed(1);
                            
                            if(totalDecline > 30){
                                keyPoints.push({
                                    date: declineStart,
                                    endDate: declineEnd,
                                    type: 'decline_period',
                                    label: `æŒç»­ä¸‹é™æœŸ ${formatDate(declineStart)} - ${formatDate(declineEnd)}`,
                                    description: `è¿ç»­ä¸‹é™${declineStreak}å¤© (${declineStartValue.toLocaleString()} â†’ ${endValue.toLocaleString()}ï¼Œä¸‹é™${totalDecline}%)`,
                                    color: '#c0392b'
                                });
                                
                                addOccupiedPeriod(declineStart, declineEnd);
                            }
                        }
                    }
                    declineStreak = 0;
                }
            }

            // ç¨³å®šæœŸ (è‡³å°‘10å¤©)
            let stableStreak = 0;
            let stableStart = null;
            let stableValues = [];
            for (let i = Math.max(1, validStartIdx); i < trafficData.length; i++) {
                if (trafficData[i-1].traffic > 0) {
                    const changeRate = Math.abs((trafficData[i].traffic - trafficData[i-1].traffic) / trafficData[i-1].traffic);
                    if (changeRate < 0.30) {
                        if (stableStreak === 0) {
                            stableStart = trafficData[i-1].date;
                            stableValues = [trafficData[i-1].traffic];
                        }
                        stableValues.push(trafficData[i].traffic);
                        stableStreak++;
                    } else {
                        if (stableStreak >= 10) {
                            const stableEnd = trafficData[i-1].date;
                            if (!isTimeOverlap(stableStart, stableEnd)) {
                                const avgTraffic = Math.round(stableValues.reduce((sum, val) => sum + val, 0) / stableValues.length);
                                const minVal = Math.min(...stableValues);
                                const maxVal = Math.max(...stableValues);
                                keyPoints.push({
                                    date: stableStart,
                                    endDate: stableEnd,
                                    type: 'stable_period',
                                    label: `ç¨³å®šæœŸ ${formatDate(stableStart)} - ${formatDate(stableEnd)}`,
                                    description: `ç¨³å®š${stableStreak}å¤©ï¼Œæµé‡èŒƒå›´${minVal.toLocaleString()}-${maxVal.toLocaleString()}ï¼Œå¹³å‡${avgTraffic.toLocaleString()}`,
                                    color: '#16a085',
                                    min: minVal,
                                    max: maxVal,
                                    avg: avgTraffic
                                });
                                addOccupiedPeriod(stableStart, stableEnd);
                            }
                        }
                        stableStreak = 0;
                        stableValues = [];
                    }
                }
            }
            // åˆå¹¶ç¨³å®šæœŸèŠ‚ç‚¹
            let mergedKeyPoints = [];
            for (let i = 0; i < keyPoints.length; i++) {
                const kp = keyPoints[i];
                if (kp.type !== 'stable_period') {
                    mergedKeyPoints.push(kp);
                    continue;
                }
                // å°è¯•ä¸ä¸Šä¸€ä¸ªç¨³å®šæœŸåˆå¹¶
                const last = mergedKeyPoints.length > 0 ? mergedKeyPoints[mergedKeyPoints.length - 1] : null;
                if (
                    last && last.type === 'stable_period' &&
                    (new Date(kp.date) - new Date(last.endDate) <= 24 * 60 * 60 * 1000 * 3)
                ) {
                    const avgDiff = kp.avg - last.avg;
                    if (avgDiff / last.avg > 0.5) {
                        // å‡å€¼æå‡è¶…è¿‡50%ï¼Œæ’å…¥ä¸Šå°é˜¶èŠ‚ç‚¹
                        const stepDate = kp.date;
                        mergedKeyPoints.push({
                            date: stepDate,
                            endDate: stepDate,
                            type: 'step_up',
                            label: `ä¸Šå°é˜¶ ${formatDate(stepDate)}`,
                            description: `æµé‡æ°´å¹³ä» ${last.avg.toLocaleString()} æå‡è‡³ ${kp.avg.toLocaleString()}`,
                            color: '#f39c12'
                        });
                        mergedKeyPoints.push(kp);
                    } else if (Math.abs(kp.avg - last.avg) / last.avg < 0.5) {
                        // å‡å€¼æ¥è¿‘ï¼Œåˆå¹¶åŒºé—´
                        last.endDate = kp.endDate;
                        last.min = Math.min(last.min, kp.min);
                        last.max = Math.max(last.max, kp.max);
                        last.avg = Math.round((last.avg + kp.avg) / 2);
                        last.label = `ç¨³å®šæœŸ ${formatDate(last.date)} - ${formatDate(last.endDate)}`;
                        const days = Math.round((new Date(last.endDate) - new Date(last.date)) / (24*60*60*1000) + 1);
                        last.description = `ç¨³å®š${days}å¤©ï¼Œæµé‡èŒƒå›´${last.min.toLocaleString()}-${last.max.toLocaleString()}ï¼Œå¹³å‡${last.avg.toLocaleString()}`;
                    } else {
                        mergedKeyPoints.push(kp);
                    }
                } else {
                    mergedKeyPoints.push(kp);
                }
            }
            keyPoints = mergedKeyPoints;

            // æ–°å¢ï¼šæµé‡ä½è°·æœŸè¯†åˆ«ï¼ˆæµé‡è¿ç»­ä½äºé˜ˆå€¼ï¼Œä¸”æŒç»­å¤©æ•°å¤§äº5å¤©ï¼‰
            const avgAll = trafficData.reduce((sum, item) => sum + item.traffic, 0) / trafficData.length;
            const minThreshold = avgAll * 0.3; // ä½äºå…¨å±€å‡å€¼30%ç®—ä½è°·
            let valleyStreak = 0;
            let valleyStart = null;
            let valleyValues = [];
            for (let i = validStartIdx; i < trafficData.length; i++) {
                if (trafficData[i].traffic > 0 && trafficData[i].traffic < minThreshold) {
                    if (valleyStreak === 0) {
                        valleyStart = trafficData[i].date;
                        valleyValues = [trafficData[i].traffic];
                    } else {
                        valleyValues.push(trafficData[i].traffic);
                    }
                    valleyStreak++;
                } else {
                    if (valleyStreak >= 5) {
                        const valleyEnd = trafficData[i - 1].date;
                        if (!isTimeOverlap(valleyStart, valleyEnd)) {
                            const avgValley = Math.round(valleyValues.reduce((sum, v) => sum + v, 0) / valleyValues.length);
                            const minVal = Math.min(...valleyValues);
                            keyPoints.push({
                                date: valleyStart,
                                endDate: valleyEnd,
                                type: 'valley_period',
                                label: `æµé‡ä½è°·æœŸ ${formatDate(valleyStart)} - ${formatDate(valleyEnd)}`,
                                description: `è¿ç»­${valleyStreak}å¤©æµé‡ä½è¿·ï¼Œæœ€ä½${minVal.toLocaleString()}ï¼Œå¹³å‡${avgValley.toLocaleString()}`,
                                color: '#34495e'
                            });
                            addOccupiedPeriod(valleyStart, valleyEnd);
                        }
                    }
                    valleyStreak = 0;
                    valleyValues = [];
                }
            }
            // ç»“å°¾ä¹Ÿè¦åˆ¤æ–­
            if (valleyStreak >= 5) {
                const valleyEnd = trafficData[trafficData.length - 1].date;
                if (!isTimeOverlap(valleyStart, valleyEnd)) {
                    const avgValley = Math.round(valleyValues.reduce((sum, v) => sum + v, 0) / valleyValues.length);
                    const minVal = Math.min(...valleyValues);
                    keyPoints.push({
                        date: valleyStart,
                        endDate: valleyEnd,
                        type: 'valley_period',
                        label: `æµé‡ä½è°·æœŸ ${formatDate(valleyStart)} - ${formatDate(valleyEnd)}`,
                        description: `è¿ç»­${valleyStreak}å¤©æµé‡ä½è¿·ï¼Œæœ€ä½${minVal.toLocaleString()}ï¼Œå¹³å‡${avgValley.toLocaleString()}`,
                        color: '#34495e'
                    });
                    addOccupiedPeriod(valleyStart, valleyEnd);
                }
            }

            // 2. ç„¶åè¯†åˆ«å•ç‚¹äº‹ä»¶
            // --- æ–°çš„ä¸Šå°é˜¶åŒºé—´è¯†åˆ«é€»è¾‘ ---
            // å…ˆæ”¶é›†æ‰€æœ‰ä¸Šå°é˜¶ç‚¹
            const stepUps = [];
            for (let i = Math.max(1, validStartIdx); i < trafficData.length; i++) {
                const current = trafficData[i];
                const previous = trafficData[i - 1];
                const growthRate = (current.traffic - previous.traffic) / previous.traffic;
                const absoluteGrowth = current.traffic - previous.traffic;
                if (absoluteGrowth > 500 && growthRate > 0.5) {
                    // è®¡ç®—ç»´æŒå¤©æ•°
                    let sustainedDays = 0;
                    const threshold = current.traffic * 0.8;
                    for (let j = i; j < Math.min(i + 30, trafficData.length); j++) {
                        if (trafficData[j].traffic >= threshold) {
                            sustainedDays++;
                        } else {
                            break;
                        }
                    }
                    if (sustainedDays >= 3) {
                        stepUps.push({
                            index: i,
                            date: current.date,
                            prevValue: previous.traffic,
                            newValue: current.traffic,
                            sustainedDays
                        });
                    }
                }
            }
            // è®¡ç®—æ¯ä¸ªå°é˜¶çš„ç»“æŸæ—¶é—´
            for (let k = 0; k < stepUps.length; k++) {
                const startIdx = stepUps[k].index;
                const startDate = stepUps[k].date;
                let endIdx = startIdx + stepUps[k].sustainedDays - 1;
                // å¦‚æœä¸‹ä¸€ä¸ªå°é˜¶åœ¨ç»´æŒæœŸå†…ï¼Œæå‰ç»“æŸ
                if (k + 1 < stepUps.length && stepUps[k + 1].index <= endIdx) {
                    endIdx = stepUps[k + 1].index - 1;
                }
                const endDate = trafficData[endIdx] ? trafficData[endIdx].date : trafficData[trafficData.length - 1].date;
                if (!isTimeOverlap(startDate, endDate)) {
                    keyPoints.push({
                        date: startDate,
                        endDate: endDate,
                        type: 'step_up',
                        label: `ä¸Šå°é˜¶ ${formatDate(startDate)} - ${formatDate(endDate)}`,
                        description: `æµé‡æ°´å¹³ä» ${stepUps[k].prevValue.toLocaleString()} æå‡è‡³ ${stepUps[k].newValue.toLocaleString()} (ç»´æŒ${endIdx - startIdx + 1}å¤©)` ,
                        color: '#f39c12'
                    });
                    addOccupiedPeriod(startDate, endDate);
                }
            }
            // --- å…¶ä½™å•ç‚¹äº‹ä»¶ä¿æŒåŸæ · ---
            for (let i = Math.max(1, validStartIdx); i < trafficData.length; i++) {
                const current = trafficData[i];
                const previous = trafficData[i - 1];
                if (previous.traffic === 0) continue;
                if (isTimeOverlap(current.date, current.date)) continue;
                const growthRate = (current.traffic - previous.traffic) / previous.traffic;
                const absoluteGrowth = current.traffic - previous.traffic;
                // æµé‡çˆ†å‘ç‚¹
                if (growthRate > 0.5 && absoluteGrowth > 100) {
                    keyPoints.push({
                        date: current.date,
                        endDate: current.date,
                        type: 'surge',
                        label: `æµé‡çˆ†å‘ ${formatDate(current.date)}`,
                        description: `æµé‡æš´æ¶¨ ${Math.round(growthRate * 100)}% (${previous.traffic.toLocaleString()} â†’ ${current.traffic.toLocaleString()})`,
                        color: '#e74c3c'
                    });
                    addOccupiedPeriod(current.date, current.date);
                }
                // æµé‡å¤§å¹…ä¸‹è·Œ
                else if (growthRate < -0.5 && Math.abs(absoluteGrowth) > 200) {
                    keyPoints.push({
                        date: current.date,
                        endDate: current.date,
                        type: 'crash',
                        label: `æµé‡éª¤é™ ${formatDate(current.date)}`,
                        description: `æµé‡å¤§è·Œ ${Math.round(Math.abs(growthRate) * 100)}% (${previous.traffic.toLocaleString()} â†’ ${current.traffic.toLocaleString()})`,
                        color: '#8e44ad'
                    });
                    addOccupiedPeriod(current.date, current.date);
                }
                // ä¸‹å°é˜¶ç‚¹ï¼ˆä¿æŒåŸé€»è¾‘ï¼‰
                else if (absoluteGrowth < -300 && growthRate < -0.5) {
                    let sustainedDays = 0;
                    const threshold = current.traffic * 1.2;
                    for (let j = i; j < Math.min(i + 7, trafficData.length); j++) {
                        if (trafficData[j].traffic <= threshold) {
                            sustainedDays++;
                        }
                    }
                    if (sustainedDays >= 3) {
                        keyPoints.push({
                            date: current.date,
                            endDate: current.date,
                            type: 'step_down',
                            label: `ä¸‹å°é˜¶ ${formatDate(current.date)}`,
                            description: `æµé‡æ°´å¹³ä» ${previous.traffic.toLocaleString()} ä¸‹é™è‡³ ${current.traffic.toLocaleString()} (ç»´æŒ${sustainedDays}å¤©+)`,
                            color: '#007bff'
                        });
                        addOccupiedPeriod(current.date, current.date);
                    }
                }
            }

            // 3. æœ€åæ·»åŠ ç‰¹æ®ŠèŠ‚ç‚¹ï¼ˆå†å²å³°å€¼å’Œä½è°·ï¼‰
            const maxTraffic = Math.max(...trafficData.map(item => item.traffic));
            const peakPoint = trafficData.find(item => item.traffic === maxTraffic);
            if (peakPoint && maxTraffic > 1000 && !isTimeOverlap(peakPoint.date, peakPoint.date)) {
                keyPoints.push({
                    date: peakPoint.date,
                    endDate: peakPoint.date,
                    type: 'peak',
                    label: `å†å²å³°å€¼ ${formatDate(peakPoint.date)}`,
                    description: `è¾¾åˆ°æœ€é«˜è®¿é—®é‡ ${maxTraffic.toLocaleString()}`,
                    color: '#9b59b6'
                });
            }

            const nonZeroTraffic = trafficData.filter(item => item.traffic > 0);
            if (nonZeroTraffic.length > 30) {
                const minTraffic = Math.min(...nonZeroTraffic.slice(15).map(item => item.traffic));
                const valleyPoint = nonZeroTraffic.find(item => item.traffic === minTraffic);
                if (valleyPoint && minTraffic < maxTraffic * 0.3 && !isTimeOverlap(valleyPoint.date, valleyPoint.date)) {
                    keyPoints.push({
                        date: valleyPoint.date,
                        endDate: valleyPoint.date,
                        type: 'valley',
                        label: `å†å²ä½è°· ${formatDate(valleyPoint.date)}`,
                        description: `é™è‡³æœ€ä½è®¿é—®é‡ ${minTraffic.toLocaleString()}`,
                        color: '#34495e'
                    });
                }
            }

            // ä¿è¯ä¸Šçº¿èŠ‚ç‚¹å§‹ç»ˆä½œä¸ºç¬¬ä¸€ä¸ªå…³é”®èŠ‚ç‚¹
            if (launchDate) {
                keyPoints.push({
                    date: launchDate,
                    endDate: launchDate,
                    type: 'launch',
                    label: `ä¸Šçº¿ ${formatDate(launchDate)}`,
                    description: 'é¦–æ¬¡æœ‰è®¿é—®é‡',
                    color: '#2ecc71'
                });
            }

            // æŒ‰æ—¥æœŸæ’åº
            keyPoints.sort((a, b) => new Date(a.date) - new Date(b.date));
            // ä¿è¯ä¸Šçº¿èŠ‚ç‚¹å§‹ç»ˆåœ¨æœ€å‰é¢
            if (launchDate) {
                const launchIdx = keyPoints.findIndex(kp => kp.type === 'launch');
                if (launchIdx > 0) {
                    const [launchNode] = keyPoints.splice(launchIdx, 1);
                    keyPoints.unshift(launchNode);
                }
            }
            // è¡¥å……ï¼šåœ¨ä¸‹å°é˜¶å‰è‡ªåŠ¨æ’å…¥ä¸Šå°é˜¶äº‹ä»¶ï¼ˆå¦‚æœ‰å¿…è¦ï¼‰
            let finalKeyPoints = [];
            for (let i = 0; i < keyPoints.length; i++) {
                const kp = keyPoints[i];
                if (kp.type === 'step_down' && i > 0) {
                    // æ‰¾å‰ä¸€ä¸ªç¨³å®šæœŸæˆ–ä¸Šå°é˜¶
                    let prev = keyPoints[i - 1];
                    if (prev && (prev.type === 'stable_period' || prev.type === 'step_up')) {
                        const prevAvg = prev.avg || prev.value || 0;
                        // è§£æä¸‹å°é˜¶èµ·ç‚¹
                        let match = kp.description.match(/ä» ([\d,]+)/);
                        let stepDownStart = match ? parseInt(match[1].replace(/,/g, ''), 10) : 0;
                        if (prevAvg > 0 && stepDownStart > prevAvg * 1.5) {
                            finalKeyPoints.push({
                                date: kp.date,
                                endDate: kp.date,
                                type: 'step_up',
                                label: `ä¸Šå°é˜¶ ${formatDate(kp.date)}`,
                                description: `æµé‡æ°´å¹³ä» ${prevAvg.toLocaleString()} æå‡è‡³ ${stepDownStart.toLocaleString()}`,
                                color: '#f39c12'
                            });
                        }
                    }
                }
                finalKeyPoints.push(kp);
            }
            keyPoints = finalKeyPoints;
            return keyPoints;
        }

        function renderResults(urlData, earliestDataDate) {
            const resultsDiv = document.getElementById('results');
            
            // åˆ›å»ºæ±‡æ€»ä¿¡æ¯
            const totalUrls = urlData.length;
            const urlsWithTraffic = urlData.filter(item => item.totalTraffic > 0).length;
            
            let html = `
                <div class="summary">
                    <h3>ğŸ“ˆ æ•°æ®æ¦‚è§ˆ</h3>
                    <p>å…±åˆ†æäº† <strong>${totalUrls}</strong> ä¸ªURLï¼Œå…¶ä¸­ <strong>${urlsWithTraffic}</strong> ä¸ªæœ‰è®¿é—®é‡æ•°æ®</p>
                    ${earliestDataDate ? `<p>æ•°æ®åˆ†æèµ·å§‹æ—¶é—´ï¼š<strong>${formatDate(earliestDataDate)}</strong> (é¦–æ¬¡æœ‰è®¿é—®é‡çš„æ—¥æœŸ)</p>` : ''}
                </div>
            `;

            // æŒ‰ä¸Šçº¿æ—¶é—´æ’åºï¼Œæœ€æ—©çš„æ’åœ¨å‰é¢
            urlData.sort((a, b) => {
                // æ²¡æœ‰ä¸Šçº¿æ—¶é—´çš„æ’åœ¨æœ€å
                if (!a.launchDate && !b.launchDate) return 0;
                if (!a.launchDate) return 1;
                if (!b.launchDate) return -1;
                // æŒ‰ä¸Šçº¿æ—¶é—´ä»æ—©åˆ°æ™šæ’åº
                return new Date(a.launchDate) - new Date(b.launchDate);
            });

            urlData.forEach((item, index) => {
                const chartId = `chart-${index}`;
                html += `
                    <div class="url-card ${item.colorClass}">
                        <div class="url-header">
                            <div class="url-title">${item.url}</div>
                            <div class="url-stats">
                                ${item.launchDate ? `
                                    <div class="stat-item">
                                        <div class="stat-label">ä¸Šçº¿æ—¶é—´</div>
                                        <div class="stat-value">${formatDate(item.launchDate)}</div>
                                    </div>
                                ` : ''}
                                <div class="stat-item">
                                    <div class="stat-label">æ€»è®¿é—®é‡</div>
                                    <div class="stat-value">${item.totalTraffic.toLocaleString()}</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-label">å³°å€¼è®¿é—®é‡</div>
                                    <div class="stat-value">${item.maxTraffic.toLocaleString()}</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-label">å¹³å‡è®¿é—®é‡</div>
                                    <div class="stat-value">${item.avgTraffic.toLocaleString()}</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-label">å…³é”®èŠ‚ç‚¹</div>
                                    <div class="stat-value">${item.keyPoints.length}</div>
                                </div>
                            </div>
                        </div>
                        ${item.totalTraffic > 0 ? `
                            ${item.keyPoints.length > 0 ? `
                                <div class="key-points">
                                    <h4>ğŸ“ å…³é”®æ—¶é—´èŠ‚ç‚¹</h4>
                                    <div class="points-list">
                                        ${item.keyPoints.map(point => `
                                            <div class="point-item" style="border-left-color: ${point.color}">
                                                <div class="point-label" style="color: ${point.color}">${point.label}</div>
                                                <div class="point-desc">${point.description}</div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            <div class="chart-container">
                                <canvas id="${chartId}"></canvas>
                            </div>
                        ` : '<div class="no-data">è¯¥URLæš‚æ— è®¿é—®é‡æ•°æ®</div>'}
                    </div>
                `;
            });

            resultsDiv.innerHTML = html;

            // åˆ›å»ºå›¾è¡¨
            urlData.forEach((item, index) => {
                if (item.totalTraffic > 0) {
                    createChart(`chart-${index}`, item);
                }
            });
        }

        function createChart(canvasId, urlData) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            // å‡†å¤‡å…³é”®ç‚¹çš„æ³¨é‡Š
            const annotations = urlData.keyPoints.map(point => {
                const dataIndex = urlData.data.findIndex(item => item.date === point.date);
                return {
                    type: 'point',
                    xValue: dataIndex,
                    yValue: urlData.data[dataIndex]?.traffic || 0,
                    backgroundColor: point.color,
                    borderColor: point.color,
                    borderWidth: 3,
                    radius: 8,
                    label: {
                        display: true,
                        content: point.label,
                        position: 'top',
                        backgroundColor: point.color,
                        color: 'white',
                        padding: 4,
                        borderRadius: 4,
                        font: {
                            size: 10
                        }
                    }
                };
            });

            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: urlData.data.map(item => formatDate(item.date)),
                    datasets: [{
                        label: 'è®¿é—®é‡',
                        data: urlData.data.map(item => item.traffic),
                        borderColor: urlData.color,
                        backgroundColor: urlData.color + '20',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: urlData.color,
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const date = urlData.data[dataIndex].date;
                                    const keyPoint = urlData.keyPoints.find(point => point.date === date);
                                    return keyPoint ? [`ğŸ¯ ${keyPoint.label}: ${keyPoint.description}`] : [];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: '#e9ecef'
                            },
                            ticks: {
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: '#e9ecef'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        }
                    },
                    elements: {
                        point: {
                            hoverBackgroundColor: urlData.color
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    onHover: (event, activeElements) => {
                        event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                        
                        // é«˜äº®å…³é”®ç‚¹
                        if (activeElements.length > 0) {
                            const dataIndex = activeElements[0].index;
                            const date = urlData.data[dataIndex].date;
                            const isKeyPoint = urlData.keyPoints.some(point => point.date === date);
                            if (isKeyPoint) {
                                event.native.target.style.cursor = 'help';
                            }
                        }
                    }
                }
            });

            // æ‰‹åŠ¨æ·»åŠ å…³é”®ç‚¹æ ‡è®°
            urlData.keyPoints.forEach(point => {
                const dataIndex = urlData.data.findIndex(item => item.date === point.date);
                if (dataIndex !== -1) {
                    // ä¿®æ”¹å¯¹åº”ç‚¹çš„æ ·å¼
                    chart.data.datasets[0].pointBackgroundColor = chart.data.datasets[0].pointBackgroundColor || [];
                    chart.data.datasets[0].pointBorderColor = chart.data.datasets[0].pointBorderColor || [];
                    chart.data.datasets[0].pointRadius = chart.data.datasets[0].pointRadius || [];
                    
                    if (Array.isArray(chart.data.datasets[0].pointBackgroundColor)) {
                        chart.data.datasets[0].pointBackgroundColor[dataIndex] = point.color;
                        chart.data.datasets[0].pointBorderColor[dataIndex] = '#fff';
                        chart.data.datasets[0].pointRadius[dataIndex] = 8;
                    }
                }
            });

            chart.update();
            chartInstances.push(chart);
        }

        function formatDate(dateStr) {
            try {
                const date = new Date(dateStr);
                return date.toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
            } catch (e) {
                return dateStr;
            }
        }
    </script>
</body>
</html>